{
  "version": 3,
  "sources": ["../../common/temp/node_modules/.pnpm/idb@7.0.1/node_modules/idb/build/wrap-idb-value.js", "../../common/temp/node_modules/.pnpm/idb@7.0.1/node_modules/idb/build/index.js", "../../browser-message-broker/src/Broker.ts", "Messages.ts", "sharedWorker.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import {\r\n  IBroadcastEnvelope,\r\n  IBroadcastSyncEnvelope,\r\n  IBroker,\r\n  IBrokerState,\r\n  Subscription,\r\n  THandler,\r\n} from \"./Types\";\r\n\r\nconst BROADCAST_SYNC = \"broadcast-sync\";\r\nconst BROWSER_MESSAGE_BROKER = \"browser-message-broker\";\r\n\r\nfunction isBroadcastSync(e: IBroadcastEnvelope): e is IBroadcastSyncEnvelope {\r\n  return e.subsKey === BROADCAST_SYNC;\r\n}\r\n\r\nfunction isSyncReq(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId == undefined;\r\n}\r\nfunction isSyncResp(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId != undefined;\r\n}\r\n\r\nexport const senderId = Math.random().toString(36).substring(2, 9);\r\n\r\nfunction debounce<T extends Function>(func: T, timeout = 1) {\r\n  let timer: number;\r\n  return (...args: unknown[]) => {\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      func(...args);\r\n    }, timeout);\r\n  };\r\n}\r\n\r\nclass Broker implements IBroker {\r\n  senderId = senderId;\r\n  state = new Map<string, any>();\r\n  subscribers = new Map<string, THandler[]>();\r\n  braodcasts = new Set<string>();\r\n  private __bcChannel = new BroadcastChannel(BROWSER_MESSAGE_BROKER);\r\n\r\n  constructor() {\r\n    if (globalThis.constructor.name === \"Window\") {\r\n      const ev = new CustomEvent(\"bmb-ready\", { detail: this });\r\n      globalThis.document.dispatchEvent(ev);\r\n    }\r\n    this.__bcChannel.onmessage = this.handleBroadcast.bind(this);\r\n    this.__bcChannel.onmessageerror = this.handleBroadcastError.bind(this);\r\n\r\n    this.sendBrokerState = debounce(this.__sendBrokerState.bind(this), 2);\r\n\r\n    this.sendBrokerState();\r\n  }\r\n\r\n  private handleBroadcastError(ev: MessageEvent<IBroadcastEnvelope>) {\r\n    throw Error(\"BROADCAST FAILED: \" + ev.data);\r\n  }\r\n\r\n  private sendBrokerState: (\r\n    targetId?: string,\r\n    filterBroadcasts?: string[]\r\n  ) => void;\r\n  private __sendBrokerState(targetId?: string, filterBroadcasts?: string[]) {\r\n    let currentBroadcasts = Array.from(this.braodcasts.keys());\r\n\r\n    if (filterBroadcasts && filterBroadcasts.length > 0) {\r\n      currentBroadcasts = currentBroadcasts.filter((k) =>\r\n        filterBroadcasts.includes(k)\r\n      );\r\n    }\r\n\r\n    const availableState: { [x: string]: any } = {};\r\n    for (const x of this.state) {\r\n      if (!x[1]) continue;\r\n      if (!currentBroadcasts.includes(x[0])) continue;\r\n      availableState[x[0]] = x[1];\r\n    }\r\n\r\n    const state: IBrokerState = {\r\n      id: senderId,\r\n      availableState,\r\n      broadcasts: currentBroadcasts,\r\n    };\r\n\r\n    const ev: IBroadcastSyncEnvelope = {\r\n      subsKey: BROADCAST_SYNC,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId,\r\n      targetId,\r\n      msg: state,\r\n    };\r\n\r\n    this.__bcChannel.postMessage(ev);\r\n  }\r\n\r\n  private handleBroadcastSync(ev: IBroadcastSyncEnvelope) {\r\n    if (isSyncReq(ev))\r\n      return this.sendBrokerState(ev.senderId, ev.msg.broadcasts);\r\n    if (isSyncResp(ev)) {\r\n      for (const s of Object.entries(ev.msg.availableState)) {\r\n        if (\r\n          this.braodcasts.has(s[0]) &&\r\n          this.state.has(s[0]) &&\r\n          this.state.get(s[0]) == undefined\r\n        ) {\r\n          this.__notifySubscribers(s[0], s[1], ev.senderId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleBroadcast(ev: MessageEvent<IBroadcastEnvelope>) {\r\n    console.log(\"BROADCAST RECEIVED: \", ev.data);\r\n\r\n    if (ev.data.targetId != undefined && ev.data.targetId !== senderId) return;\r\n\r\n    if (isBroadcastSync(ev.data)) return this.handleBroadcastSync(ev.data);\r\n\r\n    return this.__notifySubscribers(\r\n      ev.data.subsKey,\r\n      ev.data.msg,\r\n      ev.data.senderId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Bridge pub/sub messages to broadcast channel\r\n   * @param subsKey\r\n   * @returns {Subscription}\r\n   */\r\n  private __configureBroadcast(subscription: Subscription<any>): void {\r\n    if (!subscription.key) {\r\n      throw new Error(`Invalid subscription`);\r\n    }\r\n    this.braodcasts.add(subscription.key);\r\n    const originalDispose = subscription.dispose;\r\n    subscription.dispose = () => {\r\n      originalDispose();\r\n      this.braodcasts.delete(subscription.key);\r\n    };\r\n    subscription.isBroadcast = true;\r\n    this.sendBrokerState();\r\n  }\r\n\r\n  GetState<T>(subsKey: string): T | undefined {\r\n    if (subsKey) {\r\n      return this.state.get(subsKey) as T;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n  async Publish(subsKey: string, msg: Object, targetId?: string) {\r\n    await this.__notifySubscribers(subsKey, msg, senderId);\r\n    const bc = this.braodcasts.has(subsKey);\r\n    if (!bc) return;\r\n\r\n    const envelope: IBroadcastEnvelope = {\r\n      subsKey,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId: senderId,\r\n      targetId: targetId,\r\n      msg,\r\n    };\r\n\r\n    this.__bcChannel.postMessage(envelope);\r\n  }\r\n\r\n  Subscribe<T>(\r\n    key: string,\r\n    handler?: THandler<T>,\r\n    enableBroadcast = false,\r\n    enableCaching = true\r\n  ): Subscription<T> {\r\n    const subs = this.subscribers.get(key) || [];\r\n    const hdl = handler as (msg: unknown) => void;\r\n    subs.push(hdl);\r\n    this.subscribers.set(key, subs);\r\n\r\n    const subscription: Subscription<T> = {\r\n      key: key,\r\n      isCached: false,\r\n      dispose: () => {\r\n        subs.splice(subs.indexOf(hdl), 1);\r\n        subscription.isDisposed = true;\r\n      },\r\n      publish: (msg, targetId?: string) => this.Publish(key, msg, targetId),\r\n      isDisposed: false,\r\n    };\r\n\r\n    if (enableBroadcast) this.__configureBroadcast(subscription);\r\n    if (enableCaching) this.state.set(key, undefined);\r\n    return subscription;\r\n  }\r\n\r\n  private async __notifySubscribers(\r\n    subsKey: string,\r\n    msg: unknown,\r\n    sId: string\r\n  ) {\r\n    const handlers = this.subscribers.get(subsKey) || [];\r\n\r\n    const allSubscribersPromises: Promise<void>[] = [];\r\n    for (const h of handlers) {\r\n      if (!h) continue;\r\n      allSubscribersPromises.push(Promise.resolve(h(msg, sId)));\r\n    }\r\n\r\n    await Promise.all(allSubscribersPromises);\r\n    if (this.state.has(subsKey)) this.state.set(subsKey, msg);\r\n  }\r\n}\r\n\r\nglobalThis.BrowserMessageBroker =\r\n  globalThis.BrowserMessageBroker || new Broker();\r\n\r\nexport const BMB = globalThis.BrowserMessageBroker;\r\nexport type { IBroker, Subscription } from \"./Types\";\r\n", "export interface ITodo {\r\n  id: number;\r\n  text: string;\r\n  isDone: boolean;\r\n}\r\nexport interface ITodoErr {\r\n  message: string;\r\n  context: Partial<ITodo>;\r\n}\r\nexport interface IModifyTodo {\r\n  id: number;\r\n  newText: string;\r\n}\r\n\r\nexport const MESSAGES = {\r\n  ADD_TODO: \"addTodo\",\r\n  TODO_ADDED: \"todoAdded\",\r\n  TODO_ERR: \"todoErr\",\r\n  MODIFY_TODO: \"modifyTodo\",\r\n  COMPLETE_TODO: \"completeTodo\",\r\n  TODO_MODIFIED: \"todoModified\",\r\n  DEL_TODO: \"delTodo\",\r\n  TODO_DELETED: \"todoDeleted\",\r\n  GET_ALL_TODOS: \"getAllTodos\",\r\n  ALL_TODOS: \"allTodos\",\r\n  TODO_SELECTED: \"todoSelected\",\r\n\r\n  CHECK_DATA_SOURCE: \"checkDataSource\",\r\n  DATA_SOURCE_READY: \"dataSourceReady\",\r\n};\r\n", "import { openDB } from \"idb\";\r\nimport { BMB } from \"browser-message-broker\";\r\nimport { IModifyTodo, ITodo, ITodoErr, MESSAGES } from \"./Messages\";\r\n\r\nconst errSubscription = BMB.Subscribe<ITodoErr>(\r\n  MESSAGES.TODO_ERR,\r\n  undefined,\r\n  true\r\n);\r\n\r\nconst addedSubscription = BMB.Subscribe<ITodo>(\r\n  MESSAGES.TODO_ADDED,\r\n  undefined,\r\n  true,\r\n  false //to avoid publishing this state to remote brokers on sync\r\n);\r\nconst deletedSubscription = BMB.Subscribe<ITodo>(\r\n  MESSAGES.TODO_DELETED,\r\n  undefined,\r\n  true,\r\n  false\r\n);\r\nconst modifiedSubscription = BMB.Subscribe<ITodo>(\r\n  MESSAGES.TODO_MODIFIED,\r\n  undefined,\r\n  true,\r\n  false\r\n);\r\nconst allSubscription = BMB.Subscribe<ITodo[]>(\r\n  MESSAGES.ALL_TODOS,\r\n  undefined,\r\n  true,\r\n  false\r\n);\r\n\r\nconst dbProm = openDB(\"Todos\", 1, {\r\n  upgrade(db) {\r\n    const store = db.createObjectStore(\"todo\", {\r\n      keyPath: \"id\",\r\n      autoIncrement: true,\r\n    });\r\n    store.createIndex(\"isDone\", \"isDone\");\r\n  },\r\n});\r\n\r\nBMB.Subscribe(MESSAGES.ADD_TODO, handleAddTodo, true, false);\r\nBMB.Subscribe(MESSAGES.COMPLETE_TODO, handleCompleteTodo, true, false);\r\nBMB.Subscribe(MESSAGES.DEL_TODO, handleDeleteTodo, true, false);\r\nBMB.Subscribe(MESSAGES.MODIFY_TODO, handleModifyTodo, true, false);\r\nBMB.Subscribe(MESSAGES.GET_ALL_TODOS, handleGetAllTodos, true, false);\r\n\r\nasync function handleGetAllTodos(_: undefined, senderId: string) {\r\n  console.log(\"handleGetAllTodos\");\r\n  try {\r\n    const db = await dbProm;\r\n    const todos = (await db.getAll(\"todo\")) as ITodo[];\r\n    allSubscription.publish(todos, senderId);\r\n  } catch (err) {\r\n    console.log(err);\r\n    errSubscription.publish({\r\n      message: `Can't get all todos`,\r\n      context: {},\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleModifyTodo(msg: IModifyTodo) {\r\n  try {\r\n    const db = await dbProm;\r\n    const todo = (await db.get(\"todo\", msg.id)) as ITodo;\r\n    todo.text = msg.newText;\r\n    await db.put(\"todo\", todo);\r\n    modifiedSubscription.publish(todo);\r\n  } catch {\r\n    errSubscription.publish({\r\n      message: `Can't modify todo. Change: text = '${msg.newText}'`,\r\n      context: { id: msg.id },\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleDeleteTodo(todo: ITodo) {\r\n  console.log(\"handleDeleteTodo\");\r\n  try {\r\n    const db = await dbProm;\r\n    await db.delete(\"todo\", todo.id);\r\n    deletedSubscription.publish(todo);\r\n  } catch {\r\n    errSubscription.publish({\r\n      message: \"Can't delete todo\",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleCompleteTodo(todo: ITodo) {\r\n  console.log(\"handleCompleteTodo\");\r\n  try {\r\n    const db = await dbProm;\r\n    await db.put(\"todo\", { ...todo, isDone: true });\r\n    todo.isDone = true;\r\n    modifiedSubscription.publish(todo);\r\n  } catch {\r\n    errSubscription.publish({\r\n      message: \"Can't complete todo\",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleAddTodo(todo: Partial<ITodo>) {\r\n  console.log(\"handleAddTodo\");\r\n  if (!todo.text || todo.text === \"\") {\r\n    errSubscription.publish({\r\n      context: todo,\r\n      message: \"Can't add todo without text\",\r\n    });\r\n    return;\r\n  }\r\n  const newTodo: Partial<ITodo> = { text: todo.text, isDone: false };\r\n\r\n  try {\r\n    const db = await dbProm;\r\n    const key = (await db.add(\"todo\", newTodo)) as number;\r\n    newTodo.id = key;\r\n    addedSubscription.publish(newTodo as ITodo);\r\n  } catch (err) {\r\n    errSubscription.publish({\r\n      message: \"Can't add todo. \",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
