{
  "version": 3,
  "sources": ["node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/wrap-idb-value.js", "node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/index.js", "node_modules/.pnpm/browser-message-broker@0.0.7/node_modules/browser-message-broker/src/ReqRepChannel.ts", "node_modules/.pnpm/browser-message-broker@0.0.7/node_modules/browser-message-broker/src/Broker.ts", "node_modules/.pnpm/browser-message-broker@0.0.7/node_modules/browser-message-broker/src/PubSubChannel.ts", "Channels.ts", "sharedWorker.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import { BMB } from \"./Broker\";\r\nimport { ChannelSettings, IReqRepChannel } from \"./Types\";\r\n\r\nconst reqRepChannels = new Map<string, ReqRepChannel>();\r\n\r\nexport class ReqRepChannel<TReq = unknown, TRep = unknown>\r\n  implements IReqRepChannel<TReq, TRep>\r\n{\r\n  async request(msg?: TReq): Promise<TRep | undefined> {\r\n    return BMB.Request<TRep>(\r\n      this.name,\r\n      msg,\r\n      this.settings.broadcast\r\n    );\r\n  }\r\n\r\n  reply(handler: (req: TReq) => TRep | Promise<TRep>) {\r\n    return BMB.Reply<TReq, TRep>(\r\n      this.name,\r\n      handler,\r\n      this.settings.broadcast\r\n    ).dispose;\r\n  }\r\n\r\n  readonly type: \"reqRep\" = \"reqRep\";\r\n\r\n  settings: ChannelSettings = {};\r\n\r\n  dispose() {\r\n    BMB.requestListeners.delete(this.name);\r\n    reqRepChannels.delete(this.name);\r\n  }\r\n\r\n  readonly name: string = \"\";\r\n\r\n  static for<TReq = unknown, TRep = unknown>(\r\n    name: string,\r\n    settings?: ChannelSettings\r\n  ): ReqRepChannel<TReq, TRep> {\r\n    if (!settings) {\r\n      const c = reqRepChannels.get(name);\r\n      if (!c) throw Error(\"Can't find channel settings\");\r\n      return c as ReqRepChannel<TReq, TRep>;\r\n    }\r\n\r\n    BMB.ConfigureChannel(\r\n      name,\r\n      settings.broadcast || false,\r\n      settings.cache || false,\r\n      settings.trace || false\r\n    );\r\n    const channel = new ReqRepChannel<TReq, TRep>(\r\n      name,\r\n      settings\r\n    );\r\n    reqRepChannels.set(name, channel);\r\n    return channel;\r\n  }\r\n  private constructor(\r\n    name: string,\r\n    settings: ChannelSettings\r\n  ) {\r\n    this.name = name;\r\n    this.settings = settings;\r\n  }\r\n}\r\n", "import {\r\n  ChannelType,\r\n  IBroadcastEnvelope,\r\n  IBroadcastSyncEnvelope,\r\n  IBroker,\r\n  IBrokerState,\r\n  ChannelSettings,\r\n  ReqSubscription,\r\n  Subscription,\r\n  THandler,\r\n} from \"./Types\";\r\n\r\nconst BROADCAST_SYNC = \"broadcast-sync\";\r\nconst BROWSER_MESSAGE_BROKER = \"browser-message-broker\";\r\n\r\nfunction isBroadcastSync(\r\n  e: IBroadcastEnvelope\r\n): e is IBroadcastSyncEnvelope {\r\n  return e.channelName === BROADCAST_SYNC;\r\n}\r\n\r\nfunction isSyncReq(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId == undefined;\r\n}\r\nfunction isSyncResp(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId != undefined;\r\n}\r\n\r\nexport const senderId = Math.random()\r\n  .toString(36)\r\n  .substring(2, 9);\r\n\r\nfunction debounce<T extends Function>(\r\n  func: T,\r\n  timeout = 1\r\n) {\r\n  let timer: number;\r\n  return (...args: unknown[]) => {\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      func(...args);\r\n    }, timeout);\r\n  };\r\n}\r\n\r\nconst channelSettings = new Map<string, ChannelSettings>();\r\n\r\nclass Broker implements IBroker {\r\n  trace: boolean = false;\r\n  senderId = senderId;\r\n  state = new Map<string, any>();\r\n  subscribers = new Map<string, THandler[]>();\r\n  braodcasts = new Set<string>();\r\n  private __bcChannel = new BroadcastChannel(\r\n    BROWSER_MESSAGE_BROKER\r\n  );\r\n\r\n  private log(\r\n    message: string,\r\n    channel: string,\r\n    ...data: unknown[]\r\n  ) {\r\n    if (this.trace || channelSettings.get(channel)?.trace)\r\n      console.log(\r\n        `[${globalThis.constructor.name}(${this.senderId})-${channel}] ${message}`,\r\n        data\r\n      );\r\n  }\r\n\r\n  constructor() {\r\n    this.__bcChannel.onmessage =\r\n      this.handleBroadcast.bind(this);\r\n    this.__bcChannel.onmessageerror =\r\n      this.handleBroadcastError.bind(this);\r\n\r\n    setTimeout(() => {\r\n      this.__sendBrokerState(undefined, undefined); // always send initial sync request\r\n    }, 0);\r\n\r\n    this.sendBrokerState = debounce(\r\n      this.__sendBrokerState.bind(this),\r\n      2\r\n    );\r\n  }\r\n\r\n  ConfigureChannel(\r\n    channelName: string,\r\n    broadcast: boolean,\r\n    cache: boolean,\r\n    trace: boolean\r\n  ): void {\r\n    channelSettings.set(channelName, {\r\n      broadcast: broadcast,\r\n      cache: cache,\r\n      trace,\r\n    });\r\n\r\n    if (cache) this.state.set(channelName, undefined);\r\n    if (broadcast) this.braodcasts.add(channelName);\r\n  }\r\n\r\n  private handleBroadcastError(\r\n    ev: MessageEvent<IBroadcastEnvelope>\r\n  ) {\r\n    throw Error(\"BROADCAST FAILED: \" + ev.data);\r\n  }\r\n\r\n  private sendBrokerState: (\r\n    targetId?: string,\r\n    filterBroadcasts?: string[]\r\n  ) => void;\r\n  private __sendBrokerState(\r\n    targetId?: string,\r\n    filterBroadcasts?: string[]\r\n  ) {\r\n    let currentBroadcasts = Array.from(\r\n      this.braodcasts.keys()\r\n    );\r\n\r\n    if (filterBroadcasts && filterBroadcasts.length > 0) {\r\n      currentBroadcasts = currentBroadcasts.filter((k) =>\r\n        filterBroadcasts.includes(k)\r\n      );\r\n    }\r\n\r\n    const availableState: { [x: string]: any } = {};\r\n    for (const x of this.state) {\r\n      if (!x[1]) continue;\r\n      if (!currentBroadcasts.includes(x[0])) continue;\r\n      availableState[x[0]] = x[1];\r\n    }\r\n\r\n    const state: IBrokerState = {\r\n      id: senderId,\r\n      availableState,\r\n      broadcasts: currentBroadcasts,\r\n    };\r\n\r\n    const ev: IBroadcastSyncEnvelope = {\r\n      channelName: BROADCAST_SYNC,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId,\r\n      targetId,\r\n      msg: state,\r\n      channelType: \"sync\",\r\n    };\r\n\r\n    this.__bcChannel.postMessage(ev);\r\n\r\n    if (targetId == undefined)\r\n      this.log(\"Broadcast sync requested\", \"\", {\r\n        brokerState: state,\r\n      });\r\n    else\r\n      this.log(\"Broadcast sync responded\", \"\", {\r\n        targetId,\r\n        brokerState: state,\r\n      });\r\n  }\r\n\r\n  private handleBroadcastSync(ev: IBroadcastSyncEnvelope) {\r\n    if (isSyncReq(ev))\r\n      return this.sendBrokerState(\r\n        ev.senderId,\r\n        ev.msg.broadcasts\r\n      );\r\n    if (isSyncResp(ev)) {\r\n      for (const s of Object.entries(\r\n        ev.msg.availableState\r\n      )) {\r\n        if (\r\n          this.braodcasts.has(s[0]) &&\r\n          this.state.has(s[0]) &&\r\n          this.state.get(s[0]) == undefined\r\n        ) {\r\n          this.__notifySubscribers(s[0], s[1], ev.senderId);\r\n        }\r\n\r\n        this.log(\r\n          \"Broadcast sync responce handled\",\r\n          \"\",\r\n          ev.msg\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleBroadcast(\r\n    ev: MessageEvent<IBroadcastEnvelope>\r\n  ) {\r\n    this.log(\r\n      \"Broadcast received\",\r\n      ev.data.channelName,\r\n      ev.data\r\n    );\r\n\r\n    if (\r\n      ev.data.targetId != undefined &&\r\n      ev.data.targetId !== senderId\r\n    ) {\r\n      this.log(\r\n        \"Broadcast ignored (different targetId)\",\r\n        ev.data.channelName\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (isBroadcastSync(ev.data))\r\n      return this.handleBroadcastSync(ev.data);\r\n\r\n    switch (ev.data.channelType) {\r\n      case \"pubSub\":\r\n        this.__notifySubscribers(\r\n          ev.data.channelName,\r\n          ev.data.msg,\r\n          ev.data.senderId\r\n        );\r\n        break;\r\n      case \"req\":\r\n        this.bridgeRequest(\r\n          ev.data.channelName,\r\n          ev.data.msg,\r\n          ev.data.senderId\r\n        );\r\n        break;\r\n      case \"rep\":\r\n        const req = this.broadcastedRequests.get(\r\n          ev.data.channelName\r\n        );\r\n        if (!req) return;\r\n\r\n        req.resolve(ev.data.msg);\r\n        this.broadcastedRequests.delete(\r\n          ev.data.channelName\r\n        );\r\n\r\n        break;\r\n    }\r\n\r\n    this.log(\r\n      \"Broadcast handled\",\r\n      ev.data.channelName,\r\n      ev.data\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Bridge pub/sub messages to broadcast channel\r\n   * @param subsKey\r\n   * @returns {Subscription}\r\n   */\r\n  private __configureBroadcast(\r\n    subscription: Subscription<any>\r\n  ): void {\r\n    if (!subscription.channelName) {\r\n      throw new Error(`Invalid subscription`);\r\n    }\r\n    this.braodcasts.add(subscription.channelName);\r\n    const originalDispose = subscription.dispose;\r\n    subscription.dispose = () => {\r\n      originalDispose();\r\n      this.braodcasts.delete(subscription.channelName);\r\n    };\r\n    subscription.isBroadcast = true;\r\n\r\n    this.sendBrokerState();\r\n  }\r\n\r\n  GetState<T>(subsKey: string): T | undefined {\r\n    if (subsKey) {\r\n      return this.state.get(subsKey) as T;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  async Broadcast(\r\n    channelName: string,\r\n    msg: unknown,\r\n    targetId?: string\r\n  ) {\r\n    this._broadcast(channelName, msg, \"pubSub\", targetId);\r\n  }\r\n\r\n  private async _broadcast(\r\n    channelName: string,\r\n    msg: unknown,\r\n    channelType: ChannelType,\r\n    targetId?: string\r\n  ) {\r\n    const settings = channelSettings.get(channelName);\r\n\r\n    this.log(\r\n      `Message broadcasted (${channelType}) to ${\r\n        targetId || \"all brokers\"\r\n      }`,\r\n      channelName,\r\n      msg\r\n    );\r\n\r\n    const _msg = await Promise.resolve(msg);\r\n    const envelope: IBroadcastEnvelope = {\r\n      channelName: channelName,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId: senderId,\r\n      targetId: targetId,\r\n      msg: _msg,\r\n      channelType,\r\n    };\r\n\r\n    if (settings?.cache) this.state.set(channelName, msg);\r\n\r\n    this.__bcChannel.postMessage(envelope);\r\n  }\r\n\r\n  async Publish(\r\n    channelName: string,\r\n    msg: unknown,\r\n    targetId?: string\r\n  ) {\r\n    this.log(`Message published`, channelName, msg);\r\n    await this.__notifySubscribers(\r\n      channelName,\r\n      msg,\r\n      senderId\r\n    );\r\n\r\n    if (!this.braodcasts.has(channelName)) return;\r\n\r\n    this._broadcast(channelName, msg, \"pubSub\", targetId);\r\n  }\r\n\r\n  private __nextMessageAwaters = new Map<\r\n    string,\r\n    {\r\n      promise: Promise<unknown>;\r\n      resolve: (msg: unknown) => unknown;\r\n    }\r\n  >();\r\n\r\n  async nextMessage<T = unknown>(\r\n    subsKey: string\r\n  ): Promise<T> {\r\n    const a = this.__nextMessageAwaters.get(subsKey);\r\n    if (a) return a.promise as Promise<T>;\r\n\r\n    const newAwaiter: {\r\n      promise: Promise<unknown>;\r\n      resolve: (msg: unknown) => void;\r\n    } = {\r\n      promise: undefined as unknown as Promise<T>,\r\n      resolve: undefined as unknown as (\r\n        msg: unknown\r\n      ) => void,\r\n    };\r\n    newAwaiter.promise = new Promise(\r\n      (res: (msg: unknown) => void) => {\r\n        newAwaiter.resolve = res;\r\n      }\r\n    );\r\n\r\n    this.__nextMessageAwaters.set(subsKey, newAwaiter);\r\n\r\n    return newAwaiter.promise as Promise<T>;\r\n  }\r\n\r\n  Subscribe<T>(\r\n    channelName: string,\r\n    handler?: THandler<T>,\r\n    broadcast = false,\r\n    cache = true\r\n  ): Subscription<T> {\r\n    const settings = channelSettings.get(channelName);\r\n    const settingsOverriden = false;\r\n    if (settings) {\r\n      broadcast = settings.broadcast || false;\r\n      cache = settings.cache || true;\r\n      settingsOverriden;\r\n    }\r\n\r\n    const subs = this.subscribers.get(channelName) || [];\r\n    const hdl = handler as (msg: unknown) => void;\r\n    subs.push(hdl);\r\n    this.subscribers.set(channelName, subs);\r\n\r\n    const subscription: Subscription<T> = {\r\n      channelName: channelName,\r\n      isCached: false,\r\n      dispose: () => {\r\n        const _subs = this.subscribers.get(channelName);\r\n\r\n        if (_subs == undefined) return;\r\n        const i = _subs.indexOf(hdl);\r\n\r\n        if (i === -1) return;\r\n        _subs.splice(i, 1);\r\n      },\r\n      publish: (msg, targetId?: string) =>\r\n        this.Publish(channelName, msg, targetId),\r\n      isDisposed: false,\r\n    };\r\n\r\n    if (broadcast) this.__configureBroadcast(subscription);\r\n    if (cache) this.state.set(channelName, undefined);\r\n\r\n    return subscription;\r\n  }\r\n\r\n  private bridgeRequest(\r\n    channelName: string,\r\n    requestData: unknown,\r\n    senderId: string\r\n  ) {\r\n    const listener = this.requestListeners.get(channelName);\r\n\r\n    if (!listener) return Promise.resolve(undefined);\r\n\r\n    return listener.handler(\r\n      requestData,\r\n      senderId\r\n    ) as Promise<unknown>;\r\n  }\r\n\r\n  Request<TRep = unknown>(\r\n    channelName: string,\r\n    requestData: unknown,\r\n    broadcast = false,\r\n    targetId?: string\r\n  ): Promise<TRep> | Promise<undefined> {\r\n    if (!broadcast) {\r\n      const listener =\r\n        this.requestListeners.get(channelName);\r\n      if (!listener) return Promise.resolve(undefined);\r\n      return listener.handler(requestData) as Promise<TRep>;\r\n    } else {\r\n      this._broadcast(\r\n        channelName,\r\n        requestData,\r\n        \"req\",\r\n        targetId\r\n      );\r\n      const req = this.broadcastedRequests.get(channelName);\r\n      if (req) req.resolve(undefined);\r\n\r\n      let resolve = undefined as unknown as (\r\n        r: unknown\r\n      ) => void;\r\n      const promise = new Promise<TRep>(\r\n        (res) => (resolve = res as (r: unknown) => void)\r\n      );\r\n      const breq = {\r\n        promise,\r\n        resolve,\r\n      };\r\n      this.broadcastedRequests.set(channelName, breq);\r\n      return breq.promise;\r\n    }\r\n  }\r\n  private broadcastedRequests = new Map<\r\n    string,\r\n    {\r\n      promise: Promise<unknown>;\r\n      resolve: (r: unknown) => void;\r\n    }\r\n  >();\r\n\r\n  Reply<TReq = unknown, TRep = unknown>(\r\n    channelName: string,\r\n    handler: (req: TReq) => TRep,\r\n    broadcast = false\r\n  ) {\r\n    if (broadcast) {\r\n      const origHandler = handler;\r\n      handler = ((msg: TReq, targetId: string) =>\r\n        this._broadcast(\r\n          channelName,\r\n          origHandler(msg),\r\n          \"rep\",\r\n          targetId\r\n        )) as unknown as (req: TReq) => TRep;\r\n    }\r\n    const reqListeners = this.requestListeners;\r\n    const subs: ReqSubscription = {\r\n      channelName,\r\n      get isDisposed() {\r\n        return reqListeners.has(channelName);\r\n      },\r\n      isBroadcast: broadcast,\r\n      handler: handler as (r: unknown) => unknown,\r\n      dispose: undefined as unknown as () => void,\r\n    };\r\n\r\n    subs.dispose = () => {\r\n      subs.isDisposed = true;\r\n      const currentListener =\r\n        this.requestListeners.get(channelName);\r\n      if (currentListener === subs)\r\n        this.requestListeners.delete(channelName);\r\n    };\r\n\r\n    const currentListener =\r\n      this.requestListeners.get(channelName);\r\n    if (currentListener) {\r\n      currentListener.isDisposed = true;\r\n      console.warn(\r\n        \"Request listener has been replaced: \" + channelName\r\n      );\r\n    }\r\n    this.requestListeners.set(channelName, subs);\r\n    return subs;\r\n  }\r\n\r\n  requestListeners = new Map<string, ReqSubscription>();\r\n\r\n  private async __notifySubscribers(\r\n    channelName: string,\r\n    msg: unknown,\r\n    sId: string\r\n  ) {\r\n    const handlers =\r\n      this.subscribers.get(channelName) || [];\r\n\r\n    const allSubscribersPromises: Promise<void>[] = [];\r\n    for (const h of handlers) {\r\n      if (!h) continue;\r\n      allSubscribersPromises.push(\r\n        Promise.resolve(h(msg, sId))\r\n      );\r\n      this.log(\"Handler called\", channelName, h);\r\n    }\r\n\r\n    await Promise.all(allSubscribersPromises);\r\n\r\n    if (channelSettings.get(channelName)?.cache)\r\n      this.state.set(channelName, msg);\r\n\r\n    this.__handleAwaiter(channelName, msg);\r\n\r\n    this.log(\"Message handled\", channelName, msg, this);\r\n  }\r\n\r\n  private __handleAwaiter(subsKey: string, msg: unknown) {\r\n    const awaiter = this.__nextMessageAwaters.get(subsKey);\r\n    if (!awaiter) return;\r\n\r\n    awaiter.resolve(msg);\r\n\r\n    this.__nextMessageAwaters.delete(subsKey);\r\n  }\r\n}\r\n\r\nglobalThis.BrowserMessageBroker =\r\n  globalThis.BrowserMessageBroker || new Broker();\r\n\r\nexport const BMB = globalThis.BrowserMessageBroker;\r\nexport * from \"./PubSubChannel\";\r\nexport * from \"./ReqRepChannel\";\r\n", "import { BMB } from \"./Broker\";\r\nimport {\r\n  Disposer,\r\n  ChannelSettings,\r\n  IPubSubChannel,\r\n  THandler,\r\n} from \"./Types\";\r\n\r\nconst pubSubChannels = new Map<string, PubSubChannel>();\r\n\r\nexport class PubSubChannel<TMsg = any>\r\n  implements IPubSubChannel<TMsg>\r\n{\r\n  static for<TMsg>(\r\n    name: string,\r\n    settings?: ChannelSettings\r\n  ): PubSubChannel<TMsg> {\r\n    if (!settings) {\r\n      const c = pubSubChannels.get(name);\r\n      if (!c) throw Error(\"Can't find channel settings\");\r\n      return c as PubSubChannel<TMsg>;\r\n    }\r\n\r\n    BMB.ConfigureChannel(\r\n      name,\r\n      settings.broadcast || false,\r\n      settings.cache || false,\r\n      settings.trace || false\r\n    );\r\n    const channel = new PubSubChannel<TMsg>(name, settings);\r\n    pubSubChannels.set(name, channel);\r\n    return channel;\r\n  }\r\n\r\n  private constructor(\r\n    name: string,\r\n    settings: ChannelSettings\r\n  ) {\r\n    this.name = name;\r\n    this.settings = settings;\r\n  }\r\n\r\n  async send(msg: TMsg, targetId?: string): Promise<void> {\r\n    BMB.Publish(this.name, msg, targetId);\r\n  }\r\n  static async publish<TMsg = any>(\r\n    name: string,\r\n    msg: TMsg,\r\n    targetId?: string\r\n  ) {\r\n    BMB.Publish(name, msg, targetId);\r\n  }\r\n  static async broadcast<TMsg = any>(\r\n    name: string,\r\n    msg: TMsg,\r\n    targetId?: string\r\n  ) {\r\n    BMB.Broadcast<TMsg>(name, msg, targetId);\r\n  }\r\n\r\n  subscribe(handler: THandler<TMsg>): Disposer {\r\n    const s = BMB.Subscribe(\r\n      this.name,\r\n      handler,\r\n      this.settings.broadcast,\r\n      this.settings.cache\r\n    );\r\n    return s.dispose;\r\n  }\r\n\r\n  getState(): TMsg | undefined {\r\n    return BMB.GetState(this.name);\r\n  }\r\n  static GetState<TMsg>(name: string) {\r\n    return BMB.GetState<TMsg>(name);\r\n  }\r\n\r\n  nextMessage(): Promise<TMsg> {\r\n    return BMB.nextMessage(this.name);\r\n  }\r\n\r\n  static nextMessage<TMsg>(name: string): Promise<TMsg> {\r\n    return BMB.nextMessage(name);\r\n  }\r\n\r\n  readonly type = \"pubSub\";\r\n  readonly dispose = () => {\r\n    BMB.subscribers.delete(this.name);\r\n    pubSubChannels.delete(this.name);\r\n  };\r\n\r\n  readonly name: string = \"\";\r\n  readonly settings: ChannelSettings = {};\r\n}\r\n", "import {\n  PubSubChannel,\n  ReqRepChannel,\n} from \"browser-message-broker\";\n\nexport interface ITodo {\n  id: number;\n  text: string;\n  isDone: boolean;\n}\nexport interface ITodoErr {\n  message: string;\n  context: Partial<ITodo>;\n}\nexport interface IModifyTodo {\n  id: number;\n  newText: string;\n}\n\nexport const MESSAGES = {\n  ADD_TODO: \"addTodo\",\n  TODO_ADDED: \"todoAdded\",\n  TODO_ERR: \"todoErr\",\n  MODIFY_TODO: \"modifyTodo\",\n  COMPLETE_TODO: \"completeTodo\",\n  TODO_MODIFIED: \"todoModified\",\n  DEL_TODO: \"delTodo\",\n  TODO_DELETED: \"todoDeleted\",\n  GET_ALL_TODOS: \"getAllTodos\",\n  TODO_SELECTED: \"todoSelected\",\n  CHECK_DATA_SOURCE: \"checkDataSource\",\n  DATA_SOURCE_READY: \"dataSourceReady\",\n};\n\nexport const todoAddedChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.TODO_ADDED,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\n\nexport const todoErrChannel = PubSubChannel.for<ITodoErr>(\n  MESSAGES.TODO_ERR,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\n\nexport const todoDeletedChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.TODO_DELETED,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\nexport const todoModifiedChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.TODO_MODIFIED,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\nexport const dsReadyChannel = PubSubChannel.for<boolean>(\n  MESSAGES.DATA_SOURCE_READY,\n  {\n    broadcast: true,\n    cache: true,\n  }\n);\n\nexport const addTodoChannel = PubSubChannel.for<\n  Partial<ITodo>\n>(MESSAGES.ADD_TODO, {\n  broadcast: true,\n  cache: false,\n});\n\nexport const completeTodoChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.COMPLETE_TODO,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\n\nexport const delTodoChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.DEL_TODO,\n  {\n    broadcast: true,\n    cache: false,\n  }\n);\n\nexport const modifyTodoChannel =\n  PubSubChannel.for<IModifyTodo>(MESSAGES.MODIFY_TODO, {\n    broadcast: true,\n    cache: false,\n  });\n\nexport const getAllTodosChannel = ReqRepChannel.for<\n  undefined,\n  ITodo[]\n>(MESSAGES.GET_ALL_TODOS, {\n  broadcast: true,\n});\n\nexport const todoSelectedChannel = PubSubChannel.for<ITodo>(\n  MESSAGES.TODO_SELECTED,\n  {\n    broadcast: true,\n    cache: true,\n  }\n);\n", "import { openDB } from \"idb\";\nimport {\n  addTodoChannel,\n  completeTodoChannel,\n  delTodoChannel,\n  dsReadyChannel,\n  getAllTodosChannel,\n  IModifyTodo,\n  ITodo,\n  modifyTodoChannel,\n  todoAddedChannel,\n  todoDeletedChannel,\n  todoErrChannel,\n  todoModifiedChannel,\n} from \"./Channels\";\n\nconst dbProm = openDB(\"Todos\", 1, {\n  upgrade(db) {\n    const store = db.createObjectStore(\"todo\", {\n      keyPath: \"id\",\n      autoIncrement: true,\n    });\n    store.createIndex(\"isDone\", \"isDone\");\n  },\n});\n\naddTodoChannel.subscribe(handleAddTodo);\n\ncompleteTodoChannel.subscribe(handleCompleteTodo);\n\ndelTodoChannel.subscribe(handleDeleteTodo);\n\nmodifyTodoChannel.subscribe(handleModifyTodo);\n\ngetAllTodosChannel.reply(handleGetAllTodos);\n\nasync function handleGetAllTodos(_: undefined) {\n  try {\n    const db = await dbProm;\n    const todos = (await db.getAll(\"todo\")) as ITodo[];\n    return todos;\n  } catch (err) {\n    console.log(err);\n    todoErrChannel.send({\n      message: `Can't get all todos`,\n      context: {},\n    });\n  }\n  return Promise.resolve([]);\n}\n\nasync function handleModifyTodo(msg: IModifyTodo) {\n  try {\n    const db = await dbProm;\n    const todo = (await db.get(\"todo\", msg.id)) as ITodo;\n    todo.text = msg.newText;\n    await db.put(\"todo\", todo);\n    todoModifiedChannel.send(todo);\n  } catch {\n    todoErrChannel.send({\n      message: `Can't modify todo. Change: text = '${msg.newText}'`,\n      context: { id: msg.id },\n    });\n  }\n}\n\nasync function handleDeleteTodo(todo: ITodo) {\n  try {\n    const db = await dbProm;\n    await db.delete(\"todo\", todo.id);\n    todoDeletedChannel.send(todo);\n  } catch {\n    todoErrChannel.send({\n      message: \"Can't delete todo\",\n      context: todo,\n    });\n  }\n}\n\nasync function handleCompleteTodo(todo: ITodo) {\n  try {\n    const db = await dbProm;\n    await db.put(\"todo\", { ...todo, isDone: true });\n    todo.isDone = true;\n    todoModifiedChannel.send(todo);\n  } catch {\n    todoErrChannel.send({\n      message: \"Can't complete todo\",\n      context: todo,\n    });\n  }\n}\n\nasync function handleAddTodo(todo: Partial<ITodo>) {\n  if (!todo.text || todo.text === \"\") {\n    todoErrChannel.send({\n      context: todo,\n      message: \"Can't add todo without text\",\n    });\n    return;\n  }\n  const newTodo: Partial<ITodo> = {\n    text: todo.text,\n    isDone: false,\n  };\n\n  try {\n    const db = await dbProm;\n    const key = (await db.add(\"todo\", newTodo)) as number;\n    newTodo.id = key;\n    todoAddedChannel.send(newTodo as ITodo);\n  } catch (err) {\n    todoErrChannel.send({\n      message: \"Can't add todo. \",\n      context: todo,\n    });\n  }\n}\n\ndsReadyChannel.send(true);\n"],
  "mappings": "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",
  "names": ["instanceOfAny", "object", "constructors", "c", "idbProxyableTypes", "cursorAdvanceMethods", "getIdbProxyableTypes", "getCursorAdvanceMethods", "cursorRequestMap", "transactionDoneMap", "transactionStoreNamesMap", "transformCache", "reverseTransformCache", "promisifyRequest", "request", "promise", "resolve", "reject", "unlisten", "success", "error", "wrap", "value", "cacheDonePromiseForTransaction", "tx", "done", "complete", "idbProxyTraps", "target", "prop", "receiver", "replaceTraps", "callback", "wrapFunction", "func", "storeNames", "args", "unwrap", "transformCachableValue", "newValue", "openDB", "name", "version", "blocked", "upgrade", "blocking", "terminated", "request", "openPromise", "wrap", "event", "db", "readMethods", "writeMethods", "cachedMethods", "getMethod", "target", "prop", "targetFuncName", "useIndex", "isWrite", "method", "storeName", "args", "tx", "replaceTraps", "oldTraps", "receiver", "T", "b", "s", "i", "n", "t", "S", "R", "k", "d", "B", "q", "l", "M", "e", "h", "w", "o", "r", "a", "c", "u", "g", "p", "m", "f", "MESSAGES", "todoAddedChannel", "f", "todoErrChannel", "todoDeletedChannel", "todoModifiedChannel", "dsReadyChannel", "addTodoChannel", "completeTodoChannel", "delTodoChannel", "modifyTodoChannel", "getAllTodosChannel", "b", "todoSelectedChannel", "dbProm", "openDB", "db", "addTodoChannel", "handleAddTodo", "completeTodoChannel", "handleCompleteTodo", "delTodoChannel", "handleDeleteTodo", "modifyTodoChannel", "handleModifyTodo", "getAllTodosChannel", "handleGetAllTodos", "_", "err", "todoErrChannel", "msg", "todo", "todoModifiedChannel", "todoDeletedChannel", "newTodo", "key", "todoAddedChannel", "dsReadyChannel"]
}
