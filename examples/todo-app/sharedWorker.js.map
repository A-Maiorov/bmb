{
  "version": 3,
  "sources": ["node_modules/idb/build/wrap-idb-value.js", "node_modules/idb/build/index.js", "../../browser-message-broker/src/ReqRepChannel.ts", "../../browser-message-broker/src/Broker.ts", "../../browser-message-broker/src/PubSubChannel.ts", "Channels.ts", "sharedWorker.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import { BMB } from \"./Broker\";\r\nimport { ChannelSettings, IReqRepChannel } from \"./Types\";\r\n\r\nconst reqRepChannels = new Map<string, ReqRepChannel>();\r\n\r\nexport class ReqRepChannel<TReq = unknown, TRep = unknown>\r\n  implements IReqRepChannel<TReq, TRep>\r\n{\r\n  async request(msg?: TReq): Promise<TRep | undefined> {\r\n    return BMB.Request<TRep>(\r\n      this.name,\r\n      msg,\r\n      this.settings.enableBroadcast\r\n    );\r\n  }\r\n\r\n  reply(handler: (req: TReq) => TRep | Promise<TRep>) {\r\n    return BMB.Reply<TReq, TRep>(\r\n      this.name,\r\n      handler,\r\n      this.settings.enableBroadcast\r\n    ).dispose;\r\n  }\r\n\r\n  readonly type: \"reqRep\" = \"reqRep\";\r\n\r\n  settings: ChannelSettings = {};\r\n\r\n  dispose() {\r\n    BMB.requestListeners.delete(this.name);\r\n    reqRepChannels.delete(this.name);\r\n  }\r\n\r\n  readonly name: string = \"\";\r\n\r\n  static getOrCreate<TReq = unknown, TRep = unknown>(\r\n    name: string,\r\n    settings?: ChannelSettings\r\n  ): ReqRepChannel<TReq, TRep> {\r\n    if (!settings) {\r\n      const c = reqRepChannels.get(name);\r\n      if (!c) throw Error(\"Can't find channel settings\");\r\n      return c as ReqRepChannel<TReq, TRep>;\r\n    }\r\n\r\n    BMB.ConfigureChannel(\r\n      name,\r\n      settings.enableBroadcast || false,\r\n      settings.enableCaching || false,\r\n      settings.trace || false\r\n    );\r\n    const channel = new ReqRepChannel<TReq, TRep>(\r\n      name,\r\n      settings\r\n    );\r\n    reqRepChannels.set(name, channel);\r\n    return channel;\r\n  }\r\n  private constructor(\r\n    name: string,\r\n    settings: ChannelSettings\r\n  ) {\r\n    this.name = name;\r\n    this.settings = settings;\r\n  }\r\n}\r\n", "import {\r\n  ChannelType,\r\n  IBroadcastEnvelope,\r\n  IBroadcastSyncEnvelope,\r\n  IBroker,\r\n  IBrokerState,\r\n  ChannelSettings,\r\n  ReqSubscription,\r\n  Subscription,\r\n  THandler,\r\n} from \"./Types\";\r\n\r\nconst BROADCAST_SYNC = \"broadcast-sync\";\r\nconst BROWSER_MESSAGE_BROKER = \"browser-message-broker\";\r\n\r\nfunction isBroadcastSync(\r\n  e: IBroadcastEnvelope\r\n): e is IBroadcastSyncEnvelope {\r\n  return e.channelName === BROADCAST_SYNC;\r\n}\r\n\r\nfunction isSyncReq(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId == undefined;\r\n}\r\nfunction isSyncResp(e: IBroadcastEnvelope) {\r\n  return e.senderId != undefined && e.targetId != undefined;\r\n}\r\n\r\nexport const senderId = Math.random()\r\n  .toString(36)\r\n  .substring(2, 9);\r\n\r\nfunction debounce<T extends Function>(\r\n  func: T,\r\n  timeout = 1\r\n) {\r\n  let timer: number;\r\n  return (...args: unknown[]) => {\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      func(...args);\r\n    }, timeout);\r\n  };\r\n}\r\n\r\nconst channelSettings = new Map<string, ChannelSettings>();\r\n\r\nclass Broker implements IBroker {\r\n  trace: boolean = false;\r\n  senderId = senderId;\r\n  state = new Map<string, any>();\r\n  subscribers = new Map<string, THandler[]>();\r\n  braodcasts = new Set<string>();\r\n  private __bcChannel = new BroadcastChannel(\r\n    BROWSER_MESSAGE_BROKER\r\n  );\r\n\r\n  private log(\r\n    message: string,\r\n    channel: string,\r\n    ...data: unknown[]\r\n  ) {\r\n    if (this.trace || channelSettings.get(channel)?.trace)\r\n      console.log(\r\n        `[${globalThis.constructor.name}(${this.senderId})-${channel}] ${message}`,\r\n        data\r\n      );\r\n  }\r\n\r\n  constructor() {\r\n    this.__bcChannel.onmessage =\r\n      this.handleBroadcast.bind(this);\r\n    this.__bcChannel.onmessageerror =\r\n      this.handleBroadcastError.bind(this);\r\n\r\n    setTimeout(() => {\r\n      this.__sendBrokerState(undefined, undefined); // always send initial sync request\r\n    }, 0);\r\n\r\n    this.sendBrokerState = debounce(\r\n      this.__sendBrokerState.bind(this),\r\n      2\r\n    );\r\n  }\r\n\r\n  ConfigureChannel(\r\n    channelName: string,\r\n    enableBroadcast: boolean,\r\n    enableCaching: boolean,\r\n    trace: boolean\r\n  ): void {\r\n    channelSettings.set(channelName, {\r\n      enableBroadcast,\r\n      enableCaching,\r\n      trace,\r\n    });\r\n\r\n    if (enableCaching)\r\n      this.state.set(channelName, undefined);\r\n    if (enableBroadcast) this.braodcasts.add(channelName);\r\n  }\r\n\r\n  private handleBroadcastError(\r\n    ev: MessageEvent<IBroadcastEnvelope>\r\n  ) {\r\n    throw Error(\"BROADCAST FAILED: \" + ev.data);\r\n  }\r\n\r\n  private sendBrokerState: (\r\n    targetId?: string,\r\n    filterBroadcasts?: string[]\r\n  ) => void;\r\n  private __sendBrokerState(\r\n    targetId?: string,\r\n    filterBroadcasts?: string[]\r\n  ) {\r\n    let currentBroadcasts = Array.from(\r\n      this.braodcasts.keys()\r\n    );\r\n\r\n    if (filterBroadcasts && filterBroadcasts.length > 0) {\r\n      currentBroadcasts = currentBroadcasts.filter((k) =>\r\n        filterBroadcasts.includes(k)\r\n      );\r\n    }\r\n\r\n    const availableState: { [x: string]: any } = {};\r\n    for (const x of this.state) {\r\n      if (!x[1]) continue;\r\n      if (!currentBroadcasts.includes(x[0])) continue;\r\n      availableState[x[0]] = x[1];\r\n    }\r\n\r\n    const state: IBrokerState = {\r\n      id: senderId,\r\n      availableState,\r\n      broadcasts: currentBroadcasts,\r\n    };\r\n\r\n    const ev: IBroadcastSyncEnvelope = {\r\n      channelName: BROADCAST_SYNC,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId,\r\n      targetId,\r\n      msg: state,\r\n      channelType: \"sync\",\r\n    };\r\n\r\n    this.__bcChannel.postMessage(ev);\r\n\r\n    if (targetId == undefined)\r\n      this.log(\"Broadcast sync requested\", \"\", {\r\n        brokerState: state,\r\n      });\r\n    else\r\n      this.log(\"Broadcast sync responded\", \"\", {\r\n        targetId,\r\n        brokerState: state,\r\n      });\r\n  }\r\n\r\n  private handleBroadcastSync(ev: IBroadcastSyncEnvelope) {\r\n    if (isSyncReq(ev))\r\n      return this.sendBrokerState(\r\n        ev.senderId,\r\n        ev.msg.broadcasts\r\n      );\r\n    if (isSyncResp(ev)) {\r\n      for (const s of Object.entries(\r\n        ev.msg.availableState\r\n      )) {\r\n        if (\r\n          this.braodcasts.has(s[0]) &&\r\n          this.state.has(s[0]) &&\r\n          this.state.get(s[0]) == undefined\r\n        ) {\r\n          this.__notifySubscribers(s[0], s[1], ev.senderId);\r\n        }\r\n\r\n        this.log(\r\n          \"Broadcast sync responce handled\",\r\n          \"\",\r\n          ev.msg\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleBroadcast(\r\n    ev: MessageEvent<IBroadcastEnvelope>\r\n  ) {\r\n    this.log(\r\n      \"Broadcast received\",\r\n      ev.data.channelName,\r\n      ev.data\r\n    );\r\n\r\n    if (\r\n      ev.data.targetId != undefined &&\r\n      ev.data.targetId !== senderId\r\n    ) {\r\n      this.log(\r\n        \"Broadcast ignored (different targetId)\",\r\n        ev.data.channelName\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (isBroadcastSync(ev.data))\r\n      return this.handleBroadcastSync(ev.data);\r\n\r\n    switch (ev.data.channelType) {\r\n      case \"pubSub\":\r\n        this.__notifySubscribers(\r\n          ev.data.channelName,\r\n          ev.data.msg,\r\n          ev.data.senderId\r\n        );\r\n        break;\r\n      case \"req\":\r\n        this.bridgeRequest(\r\n          ev.data.channelName,\r\n          ev.data.msg,\r\n          ev.data.senderId\r\n        );\r\n        break;\r\n      case \"rep\":\r\n        const req = this.broadcastedRequests.get(\r\n          ev.data.channelName\r\n        );\r\n        if (!req) return;\r\n\r\n        req.resolve(ev.data.msg);\r\n        this.broadcastedRequests.delete(\r\n          ev.data.channelName\r\n        );\r\n\r\n        break;\r\n    }\r\n\r\n    this.log(\r\n      \"Broadcast handled\",\r\n      ev.data.channelName,\r\n      ev.data\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Bridge pub/sub messages to broadcast channel\r\n   * @param subsKey\r\n   * @returns {Subscription}\r\n   */\r\n  private __configureBroadcast(\r\n    subscription: Subscription<any>\r\n  ): void {\r\n    if (!subscription.channelName) {\r\n      throw new Error(`Invalid subscription`);\r\n    }\r\n    this.braodcasts.add(subscription.channelName);\r\n    const originalDispose = subscription.dispose;\r\n    subscription.dispose = () => {\r\n      originalDispose();\r\n      this.braodcasts.delete(subscription.channelName);\r\n    };\r\n    subscription.isBroadcast = true;\r\n\r\n    this.sendBrokerState();\r\n  }\r\n\r\n  GetState<T>(subsKey: string): T | undefined {\r\n    if (subsKey) {\r\n      return this.state.get(subsKey) as T;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  async Broadcast(\r\n    channelName: string,\r\n    msg: unknown,\r\n    targetId?: string\r\n  ) {\r\n    this._broadcast(channelName, msg, \"pubSub\", targetId);\r\n  }\r\n\r\n  private async _broadcast(\r\n    channelName: string,\r\n    msg: unknown,\r\n    channelType: ChannelType,\r\n    targetId?: string\r\n  ) {\r\n    const settings = channelSettings.get(channelName);\r\n\r\n    this.log(\r\n      `Message broadcasted (${channelType}) to ${\r\n        targetId || \"all brokers\"\r\n      }`,\r\n      channelName,\r\n      msg\r\n    );\r\n\r\n    const _msg = await Promise.resolve(msg);\r\n    const envelope: IBroadcastEnvelope = {\r\n      channelName: channelName,\r\n      senderCtx: globalThis.constructor.name,\r\n      senderId: senderId,\r\n      targetId: targetId,\r\n      msg: _msg,\r\n      channelType,\r\n    };\r\n\r\n    if (settings?.enableCaching)\r\n      this.state.set(channelName, msg);\r\n\r\n    this.__bcChannel.postMessage(envelope);\r\n  }\r\n\r\n  async Publish(\r\n    channelName: string,\r\n    msg: unknown,\r\n    targetId?: string\r\n  ) {\r\n    this.log(`Message published`, channelName, msg);\r\n    await this.__notifySubscribers(\r\n      channelName,\r\n      msg,\r\n      senderId\r\n    );\r\n\r\n    if (!this.braodcasts.has(channelName)) return;\r\n\r\n    this._broadcast(channelName, msg, \"pubSub\", targetId);\r\n  }\r\n\r\n  private __nextMessageAwaters = new Map<\r\n    string,\r\n    {\r\n      promise: Promise<unknown>;\r\n      resolve: (msg: unknown) => unknown;\r\n    }\r\n  >();\r\n\r\n  async nextMessage<T = unknown>(\r\n    subsKey: string\r\n  ): Promise<T> {\r\n    const a = this.__nextMessageAwaters.get(subsKey);\r\n    if (a) return a.promise as Promise<T>;\r\n\r\n    const newAwaiter: {\r\n      promise: Promise<unknown>;\r\n      resolve: (msg: unknown) => void;\r\n    } = {\r\n      promise: undefined as unknown as Promise<T>,\r\n      resolve: undefined as unknown as (\r\n        msg: unknown\r\n      ) => void,\r\n    };\r\n    newAwaiter.promise = new Promise(\r\n      (res: (msg: unknown) => void) => {\r\n        newAwaiter.resolve = res;\r\n      }\r\n    );\r\n\r\n    this.__nextMessageAwaters.set(subsKey, newAwaiter);\r\n\r\n    return newAwaiter.promise as Promise<T>;\r\n  }\r\n\r\n  Subscribe<T>(\r\n    channelName: string,\r\n    handler?: THandler<T>,\r\n    enableBroadcast = false,\r\n    enableCaching = true\r\n  ): Subscription<T> {\r\n    const settings = channelSettings.get(channelName);\r\n    const settingsOverriden = false;\r\n    if (settings) {\r\n      enableBroadcast = settings.enableBroadcast || false;\r\n      enableCaching = settings.enableCaching || true;\r\n      settingsOverriden;\r\n    }\r\n\r\n    const subs = this.subscribers.get(channelName) || [];\r\n    const hdl = handler as (msg: unknown) => void;\r\n    subs.push(hdl);\r\n    this.subscribers.set(channelName, subs);\r\n\r\n    const subscription: Subscription<T> = {\r\n      channelName: channelName,\r\n      isCached: false,\r\n      dispose: () => {\r\n        const _subs = this.subscribers.get(channelName);\r\n\r\n        if (_subs == undefined) return;\r\n        const i = _subs.indexOf(hdl);\r\n\r\n        if (i === -1) return;\r\n        _subs.splice(i, 1);\r\n      },\r\n      publish: (msg, targetId?: string) =>\r\n        this.Publish(channelName, msg, targetId),\r\n      isDisposed: false,\r\n    };\r\n\r\n    if (enableBroadcast)\r\n      this.__configureBroadcast(subscription);\r\n    if (enableCaching)\r\n      this.state.set(channelName, undefined);\r\n\r\n    return subscription;\r\n  }\r\n\r\n  private bridgeRequest(\r\n    channelName: string,\r\n    requestData: unknown,\r\n    senderId: string\r\n  ) {\r\n    const listener = this.requestListeners.get(channelName);\r\n\r\n    if (!listener) return Promise.resolve(undefined);\r\n\r\n    return listener.handler(\r\n      requestData,\r\n      senderId\r\n    ) as Promise<unknown>;\r\n  }\r\n\r\n  Request<TRep = unknown>(\r\n    channelName: string,\r\n    requestData: unknown,\r\n    enableBroadcast = false,\r\n    targetId?: string\r\n  ): Promise<TRep> | Promise<undefined> {\r\n    if (!enableBroadcast) {\r\n      const listener =\r\n        this.requestListeners.get(channelName);\r\n      if (!listener) return Promise.resolve(undefined);\r\n      return listener.handler(requestData) as Promise<TRep>;\r\n    } else {\r\n      this._broadcast(\r\n        channelName,\r\n        requestData,\r\n        \"req\",\r\n        targetId\r\n      );\r\n      const req = this.broadcastedRequests.get(channelName);\r\n      if (req) req.resolve(undefined);\r\n\r\n      let resolve = undefined as unknown as (\r\n        r: unknown\r\n      ) => void;\r\n      const promise = new Promise<TRep>(\r\n        (res) => (resolve = res as (r: unknown) => void)\r\n      );\r\n      const breq = {\r\n        promise,\r\n        resolve,\r\n      };\r\n      this.broadcastedRequests.set(channelName, breq);\r\n      return breq.promise;\r\n    }\r\n  }\r\n  private broadcastedRequests = new Map<\r\n    string,\r\n    {\r\n      promise: Promise<unknown>;\r\n      resolve: (r: unknown) => void;\r\n    }\r\n  >();\r\n\r\n  Reply<TReq = unknown, TRep = unknown>(\r\n    channelName: string,\r\n    handler: (req: TReq) => TRep,\r\n    enableBroadcast = false\r\n  ) {\r\n    if (enableBroadcast) {\r\n      const origHandler = handler;\r\n      handler = ((msg: TReq, targetId: string) =>\r\n        this._broadcast(\r\n          channelName,\r\n          origHandler(msg),\r\n          \"rep\",\r\n          targetId\r\n        )) as unknown as (req: TReq) => TRep;\r\n    }\r\n    const reqListeners = this.requestListeners;\r\n    const subs: ReqSubscription = {\r\n      channelName,\r\n      get isDisposed() {\r\n        return reqListeners.has(channelName);\r\n      },\r\n      isBroadcast: enableBroadcast,\r\n      handler: handler as (r: unknown) => unknown,\r\n      dispose: undefined as unknown as () => void,\r\n    };\r\n\r\n    subs.dispose = () => {\r\n      subs.isDisposed = true;\r\n      const currentListener =\r\n        this.requestListeners.get(channelName);\r\n      if (currentListener === subs)\r\n        this.requestListeners.delete(channelName);\r\n    };\r\n\r\n    const currentListener =\r\n      this.requestListeners.get(channelName);\r\n    if (currentListener) {\r\n      currentListener.isDisposed = true;\r\n      console.warn(\r\n        \"Request listener has been replaced: \" + channelName\r\n      );\r\n    }\r\n    this.requestListeners.set(channelName, subs);\r\n    return subs;\r\n  }\r\n\r\n  requestListeners = new Map<string, ReqSubscription>();\r\n\r\n  private async __notifySubscribers(\r\n    channelName: string,\r\n    msg: unknown,\r\n    sId: string\r\n  ) {\r\n    const handlers =\r\n      this.subscribers.get(channelName) || [];\r\n\r\n    const allSubscribersPromises: Promise<void>[] = [];\r\n    for (const h of handlers) {\r\n      if (!h) continue;\r\n      allSubscribersPromises.push(\r\n        Promise.resolve(h(msg, sId))\r\n      );\r\n      this.log(\"Handler called\", channelName, h);\r\n    }\r\n\r\n    await Promise.all(allSubscribersPromises);\r\n\r\n    if (this.state.has(channelName))\r\n      this.state.set(channelName, msg);\r\n\r\n    this.__handleAwaiter(channelName, msg);\r\n\r\n    this.log(\"Message handled\", channelName, msg, this);\r\n  }\r\n\r\n  private __handleAwaiter(subsKey: string, msg: unknown) {\r\n    const awaiter = this.__nextMessageAwaters.get(subsKey);\r\n    if (!awaiter) return;\r\n\r\n    awaiter.resolve(msg);\r\n\r\n    this.__nextMessageAwaters.delete(subsKey);\r\n  }\r\n}\r\n\r\nglobalThis.BrowserMessageBroker =\r\n  globalThis.BrowserMessageBroker || new Broker();\r\n\r\nexport const BMB = globalThis.BrowserMessageBroker;\r\nexport type { IBroker, Subscription } from \"./Types\";\r\nexport * from \"./PubSubChannel\";\r\nexport * from \"./ReqRepChannel\";\r\n", "import { BMB } from \"./Broker\";\r\nimport {\r\n  Disposer,\r\n  ChannelSettings,\r\n  IPubSubChannel,\r\n  THandler,\r\n} from \"./Types\";\r\n\r\nconst pubSubChannels = new Map<string, PubSubChannel>();\r\n\r\nexport class PubSubChannel<TMsg = any>\r\n  implements IPubSubChannel<TMsg>\r\n{\r\n  static getOrCreate<TMsg>(\r\n    name: string,\r\n    settings?: ChannelSettings\r\n  ): PubSubChannel<TMsg> {\r\n    if (!settings) {\r\n      const c = pubSubChannels.get(name);\r\n      if (!c) throw Error(\"Can't find channel settings\");\r\n      return c as PubSubChannel<TMsg>;\r\n    }\r\n\r\n    BMB.ConfigureChannel(\r\n      name,\r\n      settings.enableBroadcast || false,\r\n      settings.enableCaching || false,\r\n      settings.trace || false\r\n    );\r\n    const channel = new PubSubChannel<TMsg>(name, settings);\r\n    pubSubChannels.set(name, channel);\r\n    return channel;\r\n  }\r\n\r\n  private constructor(\r\n    name: string,\r\n    settings: ChannelSettings\r\n  ) {\r\n    this.name = name;\r\n    this.settings = settings;\r\n  }\r\n\r\n  async send(msg: TMsg, targetId?: string): Promise<void> {\r\n    BMB.Publish(this.name, msg, targetId);\r\n  }\r\n  static async publish<TMsg = any>(\r\n    name: string,\r\n    msg: TMsg,\r\n    targetId?: string\r\n  ) {\r\n    BMB.Publish(name, msg, targetId);\r\n  }\r\n  static async broadcast<TMsg = any>(\r\n    name: string,\r\n    msg: TMsg,\r\n    targetId?: string\r\n  ) {\r\n    BMB.Broadcast<TMsg>(name, msg, targetId);\r\n  }\r\n\r\n  subscribe(handler: THandler<TMsg>): Disposer {\r\n    const s = BMB.Subscribe(\r\n      this.name,\r\n      handler,\r\n      this.settings.enableBroadcast,\r\n      this.settings.enableCaching\r\n    );\r\n    return s.dispose;\r\n  }\r\n\r\n  getState(): TMsg | undefined {\r\n    return BMB.GetState(this.name);\r\n  }\r\n  static GetState<TMsg>(name: string) {\r\n    return BMB.GetState<TMsg>(name);\r\n  }\r\n\r\n  nextMessage(): Promise<TMsg> {\r\n    return BMB.nextMessage(this.name);\r\n  }\r\n\r\n  static nextMessage<TMsg>(name: string): Promise<TMsg> {\r\n    return BMB.nextMessage(name);\r\n  }\r\n\r\n  readonly type = \"pubSub\";\r\n  readonly dispose = () => {\r\n    BMB.subscribers.delete(this.name);\r\n    pubSubChannels.delete(this.name);\r\n  };\r\n\r\n  readonly name: string = \"\";\r\n  readonly settings: ChannelSettings = {};\r\n}\r\n", "import {\r\n  PubSubChannel,\r\n  ReqRepChannel,\r\n} from \"browser-message-broker\";\r\n\r\nexport interface ITodo {\r\n  id: number;\r\n  text: string;\r\n  isDone: boolean;\r\n}\r\nexport interface ITodoErr {\r\n  message: string;\r\n  context: Partial<ITodo>;\r\n}\r\nexport interface IModifyTodo {\r\n  id: number;\r\n  newText: string;\r\n}\r\n\r\nexport const MESSAGES = {\r\n  ADD_TODO: \"addTodo\",\r\n  TODO_ADDED: \"todoAdded\",\r\n  TODO_ERR: \"todoErr\",\r\n  MODIFY_TODO: \"modifyTodo\",\r\n  COMPLETE_TODO: \"completeTodo\",\r\n  TODO_MODIFIED: \"todoModified\",\r\n  DEL_TODO: \"delTodo\",\r\n  TODO_DELETED: \"todoDeleted\",\r\n  GET_ALL_TODOS: \"getAllTodos\",\r\n  TODO_SELECTED: \"todoSelected\",\r\n  CHECK_DATA_SOURCE: \"checkDataSource\",\r\n  DATA_SOURCE_READY: \"dataSourceReady\",\r\n};\r\n\r\nexport const todoAddedChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.TODO_ADDED, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\n\r\nexport const todoErrChannel =\r\n  PubSubChannel.getOrCreate<ITodoErr>(MESSAGES.TODO_ERR, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\n\r\nexport const todoDeletedChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.TODO_DELETED, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\nexport const todoModifiedChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.TODO_MODIFIED, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\nexport const dsReadyChannel =\r\n  PubSubChannel.getOrCreate<boolean>(\r\n    MESSAGES.DATA_SOURCE_READY,\r\n    {\r\n      enableBroadcast: true,\r\n      enableCaching: true,\r\n    }\r\n  );\r\n\r\nexport const addTodoChannel = PubSubChannel.getOrCreate<\r\n  Partial<ITodo>\r\n>(MESSAGES.ADD_TODO, {\r\n  enableBroadcast: true,\r\n  enableCaching: false,\r\n});\r\n\r\nexport const completeTodoChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.COMPLETE_TODO, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\n\r\nexport const delTodoChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.DEL_TODO, {\r\n    enableBroadcast: true,\r\n    enableCaching: false,\r\n  });\r\n\r\nexport const modifyTodoChannel =\r\n  PubSubChannel.getOrCreate<IModifyTodo>(\r\n    MESSAGES.MODIFY_TODO,\r\n    {\r\n      enableBroadcast: true,\r\n      enableCaching: false,\r\n    }\r\n  );\r\n\r\nexport const getAllTodosChannel = ReqRepChannel.getOrCreate<\r\n  undefined,\r\n  ITodo[]\r\n>(MESSAGES.GET_ALL_TODOS, {\r\n  enableBroadcast: true,\r\n});\r\n\r\nexport const todoSelectedChannel =\r\n  PubSubChannel.getOrCreate<ITodo>(MESSAGES.TODO_SELECTED, {\r\n    enableBroadcast: true,\r\n    enableCaching: true,\r\n  });\r\n", "import { openDB } from \"idb\";\r\nimport {\r\n  addTodoChannel,\r\n  completeTodoChannel,\r\n  delTodoChannel,\r\n  dsReadyChannel,\r\n  getAllTodosChannel,\r\n  IModifyTodo,\r\n  ITodo,\r\n  modifyTodoChannel,\r\n  todoAddedChannel,\r\n  todoDeletedChannel,\r\n  todoErrChannel,\r\n  todoModifiedChannel,\r\n} from \"./Channels\";\r\n\r\nconst dbProm = openDB(\"Todos\", 1, {\r\n  upgrade(db) {\r\n    const store = db.createObjectStore(\"todo\", {\r\n      keyPath: \"id\",\r\n      autoIncrement: true,\r\n    });\r\n    store.createIndex(\"isDone\", \"isDone\");\r\n  },\r\n});\r\n\r\naddTodoChannel.subscribe(handleAddTodo);\r\n\r\ncompleteTodoChannel.subscribe(handleCompleteTodo);\r\n\r\ndelTodoChannel.subscribe(handleDeleteTodo);\r\n\r\nmodifyTodoChannel.subscribe(handleModifyTodo);\r\n\r\ngetAllTodosChannel.reply(handleGetAllTodos);\r\n\r\nasync function handleGetAllTodos(_: undefined) {\r\n  try {\r\n    const db = await dbProm;\r\n    const todos = (await db.getAll(\"todo\")) as ITodo[];\r\n    return todos;\r\n  } catch (err) {\r\n    console.log(err);\r\n    todoErrChannel.send({\r\n      message: `Can't get all todos`,\r\n      context: {},\r\n    });\r\n  }\r\n  return Promise.resolve([]);\r\n}\r\n\r\nasync function handleModifyTodo(msg: IModifyTodo) {\r\n  try {\r\n    const db = await dbProm;\r\n    const todo = (await db.get(\"todo\", msg.id)) as ITodo;\r\n    todo.text = msg.newText;\r\n    await db.put(\"todo\", todo);\r\n    todoModifiedChannel.send(todo);\r\n  } catch {\r\n    todoErrChannel.send({\r\n      message: `Can't modify todo. Change: text = '${msg.newText}'`,\r\n      context: { id: msg.id },\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleDeleteTodo(todo: ITodo) {\r\n  try {\r\n    const db = await dbProm;\r\n    await db.delete(\"todo\", todo.id);\r\n    todoDeletedChannel.send(todo);\r\n  } catch {\r\n    todoErrChannel.send({\r\n      message: \"Can't delete todo\",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleCompleteTodo(todo: ITodo) {\r\n  try {\r\n    const db = await dbProm;\r\n    await db.put(\"todo\", { ...todo, isDone: true });\r\n    todo.isDone = true;\r\n    todoModifiedChannel.send(todo);\r\n  } catch {\r\n    todoErrChannel.send({\r\n      message: \"Can't complete todo\",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n\r\nasync function handleAddTodo(todo: Partial<ITodo>) {\r\n  if (!todo.text || todo.text === \"\") {\r\n    todoErrChannel.send({\r\n      context: todo,\r\n      message: \"Can't add todo without text\",\r\n    });\r\n    return;\r\n  }\r\n  const newTodo: Partial<ITodo> = {\r\n    text: todo.text,\r\n    isDone: false,\r\n  };\r\n\r\n  try {\r\n    const db = await dbProm;\r\n    const key = (await db.add(\"todo\", newTodo)) as number;\r\n    newTodo.id = key;\r\n    todoAddedChannel.send(newTodo as ITodo);\r\n  } catch (err) {\r\n    todoErrChannel.send({\r\n      message: \"Can't add todo. \",\r\n      context: todo,\r\n    });\r\n  }\r\n}\r\n\r\ndsReadyChannel.send(true);\r\n"],
  "mappings": "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",
  "names": []
}
